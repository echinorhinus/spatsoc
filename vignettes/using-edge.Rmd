---
title: "Using edge list generating functions and dyad_id"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using edge list generating functions and dyad_id}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE}
library(spatsoc)

```


TODO: ADD dyad_id
```r
#' Dyad stats
#'
#' @inheritParams dyad_id
#' @inheritParams group_pts
#' @inheritParams dyadID dyadID column name, generated by `dyad_id`
#'
#' @export
#'
#' @seealso \code{\link{dyad_id}}
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Edge list generation
#' edges <- edge_dist(DT, threshold = 100, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup', returnDist = TRUE, fillNA = TRUE)
#'
#' # Generate dyad IDs
#' dyad_id(edges, 'ID1', 'ID2')
#'
#' # Calculate dyad stats
#' dyadstats <- dyad_stats(edges, 'dyadID', 'timegroup')
dyad_stats <- function(DT = NULL,
                       dyadID = 'dyadID',
                       timegroup = NULL) {

  if (is.null(DT)) {
    stop('input DT required')
  }

  if (is.null(timegroup)) {
    stop('input timegroup required')
  }

  if (!(dyadID %in% colnames(DT)) {
    stop(paste0(dyadID,
      ' field provided are not present in input DT'
    ))
  })


  # TODO:
  # start, end for each dyad
  # mean xy for each dyad +timegroup
  # number of relocations consecutive by dyad

  d <- unique(DT[!is.na(get(dyadID)), by = c(timegroup, dyadID)])
  # d[, .(utimegroup = uniqueN(timegroup)), .(dyadID)][order(utimegroup)]
  data.table::setorderv(d, timegroup)

  uds[, shifttimegrp := get(timegroup) - shift(get(timegroup), 1), by = dyadID]

  uds[, runlen := rleid(shifttimegrp), by = dyadID]

  uds[, together := ifelse(shifttimegrp == 1, 1, .N), c('runlen', dyadID)]

}
```

`spatsoc` can be used in social network analysis to generate edge lists and spatiotemporal groups from GPS relocation data, perform data stream randomization and generate group by individual matrices.


Edge lists are generated using either the `edge_dist` or the `edge_nn` function. 

Data stream randomization is performed using the `randomizations` function. 

Group by individual matrices are generated using the `get_gbi` function.

**Note**: The grouping functions and their application in social network analysis are further described in the vignette [Using spatsoc in social network analysis - grouping functions](http://spatsoc.robitalec.ca/articles/using-in-sna.html). 


# Generate edge lists
spatsoc provides users with one temporal (`group_times`) and two edge list generating functions (`edge_dist`, `edge_nn`) to generate edge lists from GPS relocations. Users can consider edges defined by either the spatial proximity between individuals (with `edge_dist`), by nearest neighbour (with `edge_nn`) or by nearest neighbour with a maximum distance (with `edge_nn`). The edge lists can be used directly by the animal social network package `asnipe` to generate networks. 

## 1. Load packages and prepare data
`spatsoc` expects a `data.table` for all `DT` arguments and date time columns to be formatted `POSIXct`. 

```{r, message = FALSE, warning = FALSE}
## Load packages
library(spatsoc)
library(data.table)
library(asnipe)
library(igraph)

## Read data as a data.table
DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

## Cast datetime column to POSIXct
DT[, datetime := as.POSIXct(datetime)]

## Calculate the year of the relocation 
DT[, yr := year(datetime)]
```


Next, we will group relocations temporally with `group_times` and generate edges lists with one of `edge_dist`, `edge_dist`. Note: these are mutually exclusive, only select one spatial grouping function at a time. 

## 2. a) `edge_dist` 

Distance based edge lists where relocations in each timegroup are considered edges if they are within the spatial distance defined by the user with the `threshold` argument. Depending on species and study system, relevant temporal and spatial distance thresholds are used. In this case, relocations within 5 minutes and 50 meters are considered edges. 

This is the non-chain rule implementation similar to `group_pts`. Edges are defined by the distance threshold and NAs are returned for individuals within each timegroup if they are not within the threshold distance of any other individual (if `fillNA` is TRUE). 

Optionally, `edge_dist` can return the distances between individuals (less than the threshold) in a column named 'distance' with argument 'returnDist' = TRUE. 

```{r}
# Temporal groups
group_times(DT, datetime = 'datetime', threshold = '5 minutes')

# Edge list generation
edges <- edge_dist(
  DT,
  threshold = 100,
  id = 'ID',
  coords = c('X', 'Y'),
  timegroup = 'timegroup',
  returnDist = TRUE,
  fillNA = TRUE
)
```

## 2. b) `edge_nn`

Nearest neighbour based edge lists where each individual is connected to their nearest neighbour. `edge_nn` can be used to generate edge lists defined either by nearest neighbour or nearest neighbour with a maximum distance. As with grouping functions and `edge_dist`, temporal and spatial threshold depend on  species and study system. 

NAs are returned for nearest neighbour for an individual was alone in a timegroup (and/or splitBy) or if the distance between an individual and it's nearest neighbour is greater than the threshold. 

Optionally, `edge_nn` can return the distances between individuals (less than the threshold) in a column named 'distance' with argument 'returnDist' = TRUE. 

```{r, eval = FALSE}
# Temporal groups
group_times(DT, datetime = 'datetime', threshold = '5 minutes')

# Edge list generation
edges <- edge_nn(
  DT,
  id = 'ID',
  coords = c('X', 'Y'),
  timegroup = 'timegroup'
)

# Edge list generation using maximum distance threshold
edges <- edge_nn(
  DT, 
  id = 'ID', 
  coords = c('X', 'Y'),
  timegroup = 'timegroup', 
  threshold = 100
)

# Edge list generation using maximum distance threshold, returning distances
edges <- edge_nn(
  DT, 
  id = 'ID', 
  coords = c('X', 'Y'),
  timegroup = 'timegroup', 
  threshold = 100,
  returnDist = TRUE
)

```


# Build observed graph 
Once we've generated edge lists using `group_times` and one of the edge list functions, we can build the graph with `igraph`.


```{r, eval = FALSE}
# Generate observed network
g <- graph_from_edgelist(
  as.matrix(edges[, .(ID, NN)]),
  directed = FALSE
)
```


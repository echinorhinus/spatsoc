#' Group Dyads
#'
#' @inheritParams group_pts
#' @param returnDist boolean indicating if the distance between individuals should be returned. If FALSE (default), only ID1, ID2 columns (and timegroup, splitBy columns if provided) are returned. If TRUE, another column "distance" is returned indicating the distance between ID1 and ID2.
#' @param fillNA boolean indicating if NAs should be returned for individuals that were not within the threshold distance of any other. If TRUE, NAs are returned. If FALSE, only edges between individuals within the threshold distance are returned.
#'
#' @export
#'
#' @family Spatial grouping
#' @seealso \code{\link{group_times}}
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#'
group_dyad <- function(DT = NULL,
                       threshold = NULL,
                       id = NULL,
                       coords = NULL,
                       timegroup,
                       splitBy = NULL,
                       returnDist = FALSE,
                       fillNA = FALSE) {
  # due to NSE notes in R CMD check
  N <- Var1 <- Var2 <- value <- . <- NULL

  if (is.null(DT)) {
    stop('input DT required')
  }

  if (is.null(threshold)) {
    stop('threshold required')
  }

  if (!is.numeric(threshold)) {
    stop('threshold must be numeric')
  }

  if (threshold <= 0) {
    stop('threshold must be greater than 0')
  }

  if (is.null(id)) {
    stop('ID field required')
  }

  if (length(coords) != 2) {
    stop('coords requires a vector of column names for coordinates X and Y')
  }

  if (missing(timegroup)) {
    stop('timegroup required')
  }

  if (any(!(c(timegroup, id, coords, splitBy) %in% colnames(DT)))) {
    stop(paste0(
      as.character(paste(setdiff(
        c(timegroup, id, coords, splitBy),
        colnames(DT)
      ), collapse = ', ')),
      ' field(s) provided are not present in input DT'
    ))
  }

  if (any(!(DT[, vapply(.SD, is.numeric, TRUE), .SDcols = coords]))) {
    stop('coords must be numeric')
  }

  if (!is.null(timegroup)) {
    if (any(
      unlist(lapply(DT[, .SD, .SDcols = timegroup], class)) %in%
      c('POSIXct', 'POSIXlt', 'Date', 'IDate', 'ITime', 'character')
    )) {
      warning(
        strwrap(
          prefix = " ",
          initial = "",
          x = 'timegroup provided is a date/time
          or character type, did you use group_times?'
        )
      )
    }
  }

  if (is.null(timegroup) && is.null(splitBy)) {
    splitBy <- NULL
  } else {
    splitBy <- c(splitBy, timegroup)
    if (DT[, .N, by = c(id, splitBy, timegroup)][N > 1, sum(N)] != 0) {
      warning(
        strwrap(
          prefix = " ",
          initial = "",
          x = 'found duplicate id in a
          timegroup and/or splitBy -
          does your group_times threshold match the fix rate?'
        )
      )
    }
  }

  edges <- edge_dist(
    DT = DT,
    threshold = threshold,
    id = id,
    coords = coords,
    timegroup = timegroup,
    splitBy = splitBy,
    returnDist = returnDist,
    fillNA = fillNA
  )

  dyad_id(DT = edges, id1 = 'ID1', id2 = 'ID2')


  # TODO: group_dyad logic

}

#' Dyad ID
#'
#' @param id1
#' @param id2
#' @param DT input data.table with columns id1 and id2, as generated by `edge_dist` or `edge_nn`
#'
#' @return `dyad_id` returns a `data.table` with all combinations of IDs in `DT` and a dyad ID.
#'
#' @export
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Edge list generation
#' edge_dist(DT, threshold = 100, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup', returnDist = TRUE, fillNA = TRUE)
#'
#' # Generate dyad IDs
#' dyad_id(DT, 'ID1', 'ID2')
dyad_id <- function(DT, id1, id2) {
  # TODO: this is way more inefficient, use a unique then merge?

  DT[!is.na(get(id1)) & !is.na(get(id2)),
     dyadID := apply(X = .SD, MARGIN = 1, FUN = function(x) paste(sort(x), collapse = '-')),
     .SDcols = c(id1, id2)][]
}

dyad_id2 <- function(DT, id1, id2) {
  uDT <- unique(c(DT[[id1]]), by = id)
  dyads <- uDT[, CJ(ID1 = get(id), ID2 = get(id))][ID1 != ID2]
  dyads[, dyadID := apply(X = .SD, MARGIN = 1, FUN = function(x) paste(sort(x), collapse = '-'))]

  data.table::setnames(dyads, c('ID1', 'ID2'), c(id, paste0(id, 2)))



  return(dyads[])
}



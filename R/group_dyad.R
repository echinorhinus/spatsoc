#' Dyad stats
#'
#' @inheritParams dyad_id
#' @inheritParams group_pts
#' @inheritParams dyadID dyadID column name, generated by `dyad_id`
#'
#' @export
#'
#' @seealso \code{\link{dyad_id}}
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#'
group_dyad <- function(DT,
                       n = 2,
                       id1,
                       id2,
                       timegroup) {

  # TODO:
  # start, end for each dyad
  # mean xy for each dyad +timegroup
  # number of relocations consecutive by dyad

  dyad_id(DT, id1 = id1, id2 = id2)

  ds <- DT[!is.na(dyadID), .(timegroup, dyadID)]
  uds <- unique(ds)
  uds[, uniqueN(timegroup), .(dyadID)][order(V1)]
  setorder(uds, timegroup)
  uds[, shifttimegrp := timegroup - shift(timegroup, 1), by = dyadID]
  uds[, runlen := rleid(shifttimegrp), dyadID]
  uds[, together := ifelse(shifttimegrp == 1, 1, .N), .(runlen, dyadID)]


  et1 <- DT[timegroup == 641]
  d <- dcast(na.omit(et1), ID1 ~ ID2, fun.aggregate = length, drop = TRUE)
  g <-  igraph::graph_from_adjacency_matrix(as.matrix(d[, -1]))

  igraph::clusters(g)
  igraph::count_triangles(g)

  # TODO: sub down to clusters csize == 2 or == 3?
  # TODO: cast out and gen triangle id too?

}

#' Dyad ID
#'
#' @param id1 ID1 column name generated by `edge_dist` or `edge_nn`
#' @param id2 ID2 column name generated by `edge_dist` or `edge_nn`
#' @param DT input data.table with columns id1 and id2, as generated by `edge_dist` or `edge_nn`
#'
#' @return `dyad_id` returns the input `data.table` with appended "dyadID" column
#'
#' @export
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Edge list generation
#' edge_dist(DT, threshold = 100, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup', returnDist = TRUE, fillNA = TRUE)
#'
#' # Generate dyad IDs
#' dyad_id(DT, 'ID1', 'ID2')
dyad_id <- function(DT = NULL, id1 = NULL, id2 = NULL) {
  if (is.null(DT)) {
    stop('input DT required')
  }

  if (is.null(id1)) {
    stop('input DT required')
  }

  if (is.null(id2)) {
    stop('input DT required')
  }

  if (any(!(
    c(id1, id2) %in% colnames(DT)
  ))) {
    stop(paste0(
      as.character(paste(setdiff(
        c(id1, id2),
        colnames(DT)
      ), collapse = ', ')),
      ' field(s) provided are not present in input DT'
    ))
  }

  ids <- unique(na.omit(c(DT[[id1]], DT[[id2]])))
  dyads <- data.table::CJ(ID1 = ids, ID2 = ids)[ID1 != ID2]
  dyads[, dyadID :=
          apply(X = .SD, MARGIN = 1, FUN = function(x) paste(sort(x), collapse = '-'))]

  data.table::setnames(dyads, c('ID1', 'ID2'), c(id1, id2))

  return(DT[dyads, dyadID := dyadID, on = c(id1, id2)][])
}



#' Dyad stats
#'
#' @inheritParams dyad_id
#' @inheritParams group_pts
#' @inheritParams dyadID dyadID column name, generated by `dyad_id`
#'
#' @export
#'
#' @seealso \code{\link{dyad_id}}
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Edge list generation
#' edges <- edge_dist(DT, threshold = 100, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup', returnDist = TRUE, fillNA = TRUE)
#'
#' # Generate dyad IDs
#' dyad_id(edges, 'ID1', 'ID2')
#'
#' # Calculate dyad stats
#' dyadstats <- dyad_stats(edges, 'dyadID', 'timegroup')
dyad_stats <- function(DT = NULL,
                       dyadID = 'dyadID',
                       timegroup = NULL) {

  if (is.null(DT)) {
    stop('input DT required')
  }

  if (is.null(timegroup)) {
    stop('input timegroup required')
  }

  if (!(dyadID %in% colnames(DT)) {
    stop(paste0(dyadID,
      ' field provided are not present in input DT'
    ))
  })


  # TODO:
  # start, end for each dyad
  # mean xy for each dyad +timegroup
  # number of relocations consecutive by dyad

  d <- unique(DT[!is.na(get(dyadID)), by = c(timegroup, dyadID)])
  # d[, .(utimegroup = uniqueN(timegroup)), .(dyadID)][order(utimegroup)]
  data.table::setorderv(d, timegroup)

  uds[, shifttimegrp := get(timegroup) - shift(get(timegroup), 1), by = dyadID]

  uds[, runlen := rleid(shifttimegrp), by = dyadID]

  uds[, together := ifelse(shifttimegrp == 1, 1, .N), c('runlen', dyadID)]

}

#' Dyad ID
#'
#' @param id1 ID1 column name generated by `edge_dist` or `edge_nn`
#' @param id2 ID2 column name generated by `edge_dist` or `edge_nn`
#' @param DT input data.table with columns id1 and id2, as generated by `edge_dist` or `edge_nn`
#'
#' @return `dyad_id` returns the input `data.table` with appended "dyadID" column
#'
#' @export
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Edge list generation
#' edges <- edge_dist(DT, threshold = 100, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup', returnDist = TRUE, fillNA = TRUE)
#'
#' # Generate dyad IDs
#' dyad_id(edges, 'ID1', 'ID2')
dyad_id <- function(DT = NULL, id1 = NULL, id2 = NULL) {
  if (is.null(DT)) {
    stop('input DT required')
  }

  if (is.null(id1)) {
    stop('input id1 required')
  }

  if (is.null(id2)) {
    stop('input id2 required')
  }

  if (any(!(
    c(id1, id2) %in% colnames(DT)
  ))) {
    stop(paste0(
      as.character(paste(setdiff(
        c(id1, id2),
        colnames(DT)
      ), collapse = ', ')),
      ' field(s) provided are not present in input DT'
    ))
  }

  ids <- unique(na.omit(c(DT[[id1]], DT[[id2]])))
  dyads <- data.table::CJ(ID1 = ids, ID2 = ids)[ID1 != ID2]
  dyads[, dyadID :=
          apply(X = .SD, MARGIN = 1, FUN = function(x) paste(sort(x), collapse = '-'))]

  data.table::setnames(dyads, c('ID1', 'ID2'), c(id1, id2))

  return(DT[dyads, dyadID := dyadID, on = c(id1, id2)][])
}



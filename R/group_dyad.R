#' Group Dyads
#'
#' @inheritParams group_pts
#' @param returnDist boolean indicating if the distance between individuals should be returned. If FALSE (default), only ID1, ID2 columns (and timegroup, splitBy columns if provided) are returned. If TRUE, another column "distance" is returned indicating the distance between ID1 and ID2.
#' @param fillNA boolean indicating if NAs should be returned for individuals that were not within the threshold distance of any other. If TRUE, NAs are returned. If FALSE, only edges between individuals within the threshold distance are returned.
#'
#' @export
#'
#' @family Spatial grouping
#' @seealso \code{\link{group_times}}
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#'
group_dyad <- function(edges,
                       n = 2,
                       id1,
                       id2,
                       timegroup) {


  dyad_id(DT = edges, id1 = id1, id2 = id2)

  ds <- edges[!is.na(dyadID), .(timegroup, dyadID)]
  uds <- unique(ds)
  uds[, uniqueN(timegroup), .(dyadID)][order(V1)]
  setorder(uds, timegroup)
  uds[, shifttimegrp := timegroup - shift(timegroup, 1), by = dyadID]
  uds[, runlen := rleid(shifttimegrp), dyadID]
  uds[shifttimegrp == 1, together := .N, .(runlen, dyadID)]


  # TODO: by timegroup
  et1 <- edges[timegroup == 641]
  d <- dcast(na.omit(et1), ID1 ~ ID2, fun.aggregate = length, drop = TRUE)
  g <-  igraph::graph_from_adjacency_matrix(as.matrix(d[, -1]))

  igraph::clusters(g)
  igraph::count_triangles(g)

  # TODO: sub down to clusters csize == 2 or == 3?
  # TODO: cast out and gen triangle id too?

}

#' Dyad ID
#'
#' @param id1 ID1 column name generated by `edge_dist` or `edge_nn`
#' @param id2 ID2 column name generated by `edge_dist` or `edge_nn`
#' @param DT input data.table with columns id1 and id2, as generated by `edge_dist` or `edge_nn`
#'
#' @return `dyad_id` returns the input `data.table` with appended "dyadID" column
#'
#' @export
#'
#' @examples
#' # Load data.table
#' library(data.table)
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Edge list generation
#' edge_dist(DT, threshold = 100, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup', returnDist = TRUE, fillNA = TRUE)
#'
#' # Generate dyad IDs
#' dyad_id(DT, 'ID1', 'ID2')
dyad_id <- function(DT = NULL, id1 = NULL, id2 = NULL) {
  if (is.null(DT)) {
    stop('input DT required')
  }

  if (is.null(id1)) {
    stop('input DT required')
  }

  if (is.null(id2)) {
    stop('input DT required')
  }

  if (any(!(
    c(id1, id2) %in% colnames(DT)
  ))) {
    stop(paste0(
      as.character(paste(setdiff(
        c(id1, id2),
        colnames(DT)
      ), collapse = ', ')),
      ' field(s) provided are not present in input DT'
    ))
  }

  ids <- unique(na.omit(c(DT[[id1]], DT[[id2]])))
  dyads <- data.table::CJ(ID1 = ids, ID2 = ids)[ID1 != ID2]
  dyads[, dyadID := apply(X = .SD, MARGIN = 1, FUN = function(x) paste(sort(x), collapse = '-'))]

  data.table::setnames(dyads, c('ID1', 'ID2'), c(id1, id2))

  return(DT[dyads, dyadID := dyadID, on = c(id1, id2)][])
}


